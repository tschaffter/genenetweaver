function [AUC AUROC] = evaluation(testfile, goldfile, netsize)
%
% This function evaluates the accuracy of a prediction compared 
% to a gold standard.
% 
% Usage: [AUC AUROC] = 
%		evaluation(testfile, goldfile, size)
%
% INPUTS:
%	testfile:	the file containing the predictions to be evaluated
%	goldfile: 	the file containing the gold standard
%       netsize:           the size of the gold standard network (number of genes)
%                       (needed if gold standard don't contain null-interactions)
%
% OUTPUTS: 
%	AUC:		area under the precision-recall curve (also called AUPR)
%	AUROC:		area under the ROC curve
% All further information about the actual calculations can be found elsewhere.

% The algorithm was developed by Gustavo Stolovitzky and implemented by
% Bernd Jagla, Columbia University (baj2107_A_T_columbia.edu). 
% All questions/suggestions should be directed to both, Gustavo and Bernd.
%
% Gustavo A. Stolovitzky, Ph.D.
% Adj. Assoc Prof of Biomed Informatics, Columbia Univ
% Mngr, Func Genomics & Sys Biology, IBM  Research
% P.O.Box 218 					Office :  (914) 945-1292
% Yorktown Heights, NY 10598 	Fax     :  (914) 945-4217
% http://www.research.ibm.com/people/g/gustavo
% http://domino.research.ibm.com/comm/research_projects.nsf/pages/fungen.index.html 
%
% Bernd Jagla, Ph.D.
% Assoc. Rsch. Scientist
% Joint Centers for Systems Biology
% Columbia University
% Irving Cancer Res Ctr
% 1130 St Nicholas Avenue 8th Floor
% United States
%
% Robert Prill, Ph.D.
% Post-doctoral Researcher
% Computational Biology Center, IBM Research
% P.O.Box 218
% Yorktown Heights, NY 10598 	
% Office :  914-945-1377
% http://www.research.ibm.com/people/r/rjprill/
% 
%
% The original script has been modified to make it compatible with gold standard
% files generated by GeneNetWeaver (gnw.sf.net), i.e. compatible with gold standard
% files that do not contain null-interactions. Besides, PR and ROC curves are
% now plotted. Extension made on December 2008 by:
%
% Thomas Schaffter, Ph.D. Student
% Ecole Polytechnique Federale de Lausanne (EPFL)
% Laboratory of Intelligent Systems (LIS)
% CH-1015 Lausanne, Switzerland
% http://lis.epfl.ch/member.php?SCIPER=161219
%

if nargin < 2 || nargin > 3
    error('Error: bad number of parameters!')
elseif nargin == 2
    completeGoldStandard = 1;
elseif nargin == 3
    completeGoldStandard = 0;
end
    

% read goldfile
% Modif: self-interactions were assumed to be not present in the gold
%        standard. The function removeSelfInteractions() is used to make
%        the process compatible with given goldstandard containing the
%        self-interactions.
maxN = 10000000;
fid1 = fopen(goldfile, 'r');
gold = textscan(fid1,'%s%s%f', maxN);
gold = removeSelfInteractions(gold);
gold{1} = strcat('A',gold{1},'___',gold{2});
gold{2} = gold{3};
fclose(fid1);

% Conversion cells to structure
for i=1:length(gold{1})
    goldstruct.(char(gold{1}(i))) = i;
end


% read testfile
fid2 = fopen(testfile, 'r');
test = textscan(fid2,'%s%s%f', maxN);
test = removeSelfInteractions(test);
% test{1} can be a number so lets add some character before
test{1} = strcat('A', test{1}, '___', test{2});
test{2} = test{3};
fclose(fid2);


% remove all entries from test that are not in the goldstandard
% (e.g., self-edges)
% Note: self-edges sould already be removed with the use of
%       removeSelfInteractions().
% Note: this could be done only if a goldstandard with even the
%       null-interactions are specified, otherwise all predicted
%       interactions that do not match the edges given in the goldstandard
%       are considered as false positive.
if completeGoldStandard
    keepme = [];
    j = 1;
    for i=1:length(test{1})
        if isfield(goldstruct,test{1}(i))
            keepme(j) = i;
            j = j + 1;
        end
    end
    test{1} = test{1}(keepme);
    test{2} = test{2}(keepme);
end


% Analysis

% Initialization
k=0;
Ak=0;
TPk=0;
FPk=0;
% Total number of edges in the network
if completeGoldStandard
    T = length(gold{1});
else
    T = netsize.^2 - netsize;
end
% Number of interactions defined in the goldstandard
P = sum(gold{2});
% Number of interactions with null weight
N = T-P; %N = length(gold{1}) - P
% Number of interactions predicted
L = length(test{1});

% do the calculations
if ~ isempty(test{1})
    while (k < L)
        k = k + 1;
        if mod(k,1000) == 0
            disp(sprintf('%d of %d',k,L));
        end
 
        if isfield(goldstruct,test{1}(k))
            p = goldstruct.(char(test{1}(k)));
        else
            % This interaction is not listed in the interactions of the gold
	    % standard.
            p = 0;
        end
        
        %this should not happen
        if length(p) > 1
            error(char(test{1}(kk)) , ' not found');
        end
        
        
        if p == 0 || gold{2}(p) == 0
            FPk = FPk + 1;
        elseif gold{2}(p) == 1 % True positive
            TPk = TPk + 1;
            if(k==1)
                delta=1/P;  
            else            
                delta=(1-FPk*log(k/(k-1)))/P;
            end            
            Ak = Ak + delta; 
        else
            % for challange 5 ignore unknown interactions
            disp(['couldnot find ' char(test{1}(k))]);
        end
        rec(k) = TPk/P;
        prec(k) = TPk/k;
        tpr(k) = rec(k);
        fpr(k) = FPk/N;
    end
end

%% assume random accuracy for remainder of links
TPL=TPk;
if L < T
    rh = (P-TPL)/(T-L); 
else
    rh = 0;
end

if L>0
    recL = rec(L);
else
    recL = 0;
end
while TPk < P
    k = k + 1;
    TPk = TPk + 1;
    rec(k) = TPk/P;
    if ((rec(k)-recL)*P + L * rh) ~= 0
        prec(k) = rh * P * rec(k)/((rec(k)-recL)*P + L * rh);
    else
        prec(k) = 0;
    end
    tpr(k) = rec(k);
    FPk = TPk * (1-prec(k))/prec(k);
    fpr(k) = FPk/N;
end
AL = Ak;
if ~isnan(rh) && rh ~= 0  && L ~= 0 
    AUC = AL + rh * (1-recL) + rh * (recL - L * rh / P) * log((L * rh + P * (1-recL) )/(L *rh));
elseif(L==0)
    AUC = P/T;           
else
    AUC = Ak;
end

%Integrate area under ROC
lc = fpr(1) * tpr(1) /2;
for n=1:L+P-TPL-1
    lc = lc + (fpr(n+1)+fpr(n)) * (tpr(n+1)-tpr(n)) / 2;
end
AUROC = 1 - lc;

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Display PR and ROC curves
subplot(1,2,1);
shadedCurve(rec,prec);
title(['AUPR = ' sprintf('%f', AUC)]);
xlabel('Recall');
ylabel('Precision');

subplot(1,2,2);
shadedCurve(fpr,tpr);
title(['AUROC = ' sprintf('%f', AUROC)]);
xlabel('False Positive Rate');
ylabel('True Positive Rate');

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Helper functions

% Remove the self-interactions from a list of link.
function [links] = removeSelfInteractions(links)
    keepme = [];
    j = 1;
    for i=1:length(links{1})
        if strcmp(links{1}(i),links{2}(i)) ~= 1
            keepme(j) = i;
            j = j + 1;
        end
    end
    
    links{1} = links{1}(keepme);
    links{2} = links{2}(keepme);
    links{3} = links{3}(keepme);
end

% Plot a shaded curve
function shadedCurve(X,Y)
    R = 141/255;
    G = 182/255;
    B = 243/255;
    n = length(X);
    x = [1 1 0 0 X];
    y = [Y(n) 0 0 Y(1) Y];
    plot(x,y,'LineWidth',1,'Color',[0 0 0]);
    h = fill(x,y,[R G B]);
    set(h,'FaceAlpha',0.6); 
    axis([0 1 0 1]);
    axis square;
end

end
